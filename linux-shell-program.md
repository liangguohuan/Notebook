---
layout: post
title: linux shell 编程
categories: ['技术']
tags: ['shell']
published: True

---

## 内部变量

    '$HOME'     # 用户的Home目录,一般是/home/username
    '$HOSTNAME' # hostname放在一个初始化脚本中, 在系统启动的时候分配一个系统名字.
    '$IFS'      # 内部域分隔符,这个变量用来决定Bash在解释字符串时如何识别域, 或者单词边界.
                # $#IFS默认为空白(空格, 制表符,和换行符)
    '$PATH'     # 可执行文件的搜索路径, 通常情况下, 系统都是在/etc/profile和~/.bashrc中存储$PATH的定义.
    '$PWD'      # 工作目录(你当前所在的目录),这与内建命令pwd作用相同.
    '$REPLY'    # 当没有参数变量提供给read命令的时候, 这个变量会作为默认变量提供给read命令.

---------------------------

    '$#' # 传递到脚本的参数个数
    '$*' # 以一个单字符串显示所有向脚本传递的参数。与位置变量不同，此选项参数可超过9个
    '$$' # 脚本运行的当前进程ID号
    '$!' # 后台运行的最后一个进程的进程ID号
    '$@' # 以数组方式存储传递的所以参数
    '$-' # 显示shell使用的当前选项，与set命令功能相同
    '$?' # 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误

> $@:与$*相同, 但是每个参数都是一个独立的引用字符串, 这就意味着, 参数是被完整传递的, 并没有被解释或扩展. 这也意味着, 参数列表中每个参数都被看作为单独的单词. 当然, “$@”应该被引用起来.

<!-- more -->

## Bash关键字介绍

### local

> 局部变量定义

### declare

> 可以取代`local`，也是定义局部变量

    declare  [-aixr]  变量名
    '-a' # 将后面的变量名定义为数组
    '-A' # 将后面的变量名定义为关联数组
    '-i' # 将后面的变量名定义为整数
    '-x' # 将后面的变量名定义为环境变量，功能同export
    '+x' # 取消环境变量
    '-r' # 将变量名定义为readonly，不能更改不能unset

### return

> 函数返回值
> 注意：通过`return`定义返回值，必须调用函数后，用 $? 来取得返回值，
> 所以一般用`echo`来代替更加方便 

### shift

> 把可变参数最前边一个弹出

    until [ $# -eq 0 ]
    do
    echo "第一个参数为: $1 参数个数为: $#"
    shift
    done

### set

> 设置bash解析器参数

    'allexport'      '-a'     # 从设置开始标记所有新的和修改过的用于输出的变量
    'braceexpand'    '-B'     # 允许符号扩展,默认选项
    'emacs'                   # 在进行命令编辑的时候,使用内建的emacs编辑器,  默认选项
    'errexit'        '-e'     # 如果一个命令返回一个非0退出状态值(失败),就退出.
    'histexpand'     '-H'     # 在做临时替换的时候允许使用!和!!  默认选项
    'history'                 # 允许命令行历史,默认选项
    'ignoreeof'               # 禁止coontrol -D 的方式退出shell，必须输入exit。
    'interactive'    '-c'     # omments  在交互式模式下，  #用来表示注解
    'keyword'        '-k'     # 为命令把关键字参数放在环境中
    'monitor'        '-m'     # 允许作业控制
    'noclobber'      '-C'     # 保护文件在使用重新动向的时候不被覆盖
    'noexec'         '-n'     # 在脚本状态下读取命令但是不执行，主要为了检查语法结构。
    'noglob'         '-d'     # 禁止路径名扩展，即关闭通配符
    'notify'         '-b'     # 在后台作业以后通知客户
    'nounset'        '-u'     # 在扩展一个没有的设置的变量的时候，
    'onecmd'         '-t'     # 在读取并执行一个新的命令后退出
    'physical'       '-P'     # 如果被设置，则在使用pwd和cd命令时不使用符号连接的路径  而是物理路径
    'posix'                   # 改变shell行为以便符合POSIX要求
    'privileged'              # 一旦被设置，shell不再读取.profile文件和env文件  shell函数也不继承任何环境
    'verbose'        '-v'     # 为调试打开verbose模式
    'vi'                      # 在命令行编辑的时候使用内置的vi编辑器
    'xtrace'         '-x'     # 打开调试回响模式


## 逻辑运算符

### 1. 关于档案与目录的侦测逻辑卷标！

    '-f'  # 常用！侦测『档案』是否存在 eg: if [ -f filename ]
    '-d'  # 常用！侦测『目录』是否存在
    '-b'  # 侦测是否为一个『 block 档案』
    '-c'  # 侦测是否为一个『 character 档案』
    '-S'  # 侦测是否为一个『 socket 标签档案』
    '-L'  # 侦测是否为一个『 symbolic link 的档案』
    '-e'  # 侦测『某个东西』是否存在！

### 2.  关于程序的逻辑卷标！

    '-G'  # 侦测是否由 GID 所执行的程序所拥有
    '-O'  # 侦测是否由 UID 所执行的程序所拥有
    '-p'  # 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）

### 3. 关于档案的属性侦测！

    '-r'  # 侦测是否为可读的属性
    '-w'  # 侦测是否为可以写入的属性
    '-x'  # 侦测是否为可执行的属性
    '-s'  # 侦测是否为『非空白档案』
    '-u'  # 侦测是否具有『 SUID 』的属性
    '-g'  # 侦测是否具有『 SGID 』的属性
    '-k'  # 侦测是否具有『 sticky bit 』的属性

### 4. 两个档案之间的判断与比较 ；例如[ test file1 -nt file2 ]

    '-nt' # 第一个档案比第二个档案新
    '-ot' # 第一个档案比第二个档案旧
    '-ef' # 第一个档案与第二个档案为同一个档案（ link 之类的档案）
    '5.'  # 逻辑的『和(and)』『或(or)』
    '&&'  # 逻辑的 AND 的意思
    '||'  # 逻辑的 OR 的意思

### 5. 运算符号 

    '='   # 等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
    '!='  # 不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串
    '<'   # 小于 应用于：整型比较 在[] 中，不能使用 表示字符串
    '>'   # 大于 应用于：整型比较 在[] 中，不能使用 表示字符串
    '-eq' # 等于 应用于：整型比较
    '-ne' # 不等于 应用于：整型比较
    '-lt' # 小于 应用于：整型比较
    '-gt' # 大于 应用于：整型比较
    '-le' # 小于或等于 应用于：整型比较
    '-ge' # 大于或等于 应用于：整型比较
    '-a'  # 双方都成立（and） 逻辑表达式 –a 逻辑表达式
    '-o'  # 单方成立（or） 逻辑表达式 –o 逻辑表达式
    '-z'  # 空字符串
    '-n'  # 非空字符串

## shell中的括号（小括号，中括号，大括号）

### 1. 单小括号()

#### 1.1 命令组。

括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。

#### 1.2 命令替换

等同于``cmd``，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。

#### 1.3 用于初始化数组

如：array=(a b c d)

### 2. 双小括号((  ))

①整数扩展，这种扩展计算是整数型的计算，不支持浮点型。`((exp))`结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。

②只要括号中的运算符、表达式符合C语言运算规则，都可用在`$((exp))`中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：`echo $((16#5f))` 结果为95 (16进位转十进制)

③单纯用 `(( ))`也可重定义变量值，比如 `a=5; ((a++))` 可将 `$a` 重定义为6

④双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。

    if ($i<5)  
    if [ $i -lt 5 ]  
    if [ $a -ne 1 -a $a != 2 ]  
    if [ $a -ne 1] && [ $a != 2 ]  
    if [[ $a != 1 && $a != 2 ]]  
       
    for i in $(seq 0 4);do echo $i;done  
    for i in `seq 0 4`;do echo $i;done  
    for ((i=0;i<5;i++));do echo $i;done  
    for i in {0..4};do echo $i;done  

### 3. 单中括号[]

①bash 的内部命令中`[`和`test`是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。`if/test`结构中的左中括号是调用`test`的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。`if/test`结构中并不是必须右中括号，但是新版的Bash中要求必须这样。

②Test和[]中可用的比较运算符只有`==`和`!=`，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用`-eq`，`-gt`这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较`"ab"`和`"bc"`：`[ ab \< bc ]`，结果为真，也就是返回状态为0。`[ ]`中的逻辑与和逻辑或使用`-a` 和`-o`表示。

③字符范围，用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。

④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。

### 4. 双中括号[[ ]]

①`[[`是 bash 程序语言的关键字，并不是一个命令，`[[ ]]`结构比`[ ]`结构更加通用。在`[[`和`]]`之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。

②支持字符串的模式匹配，使用`=~`操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如`[[ hello == hell? ]]`，结果为真。`[[ ]]`中匹配字符串或通配符，不需要引号。

③使用`[[ ... ]]`条件判断结构，而不是`[ ... ]`能够防止脚本中的许多逻辑错误。比如，`&&`、`||`、`<`和`>`操作符能够正常存在于`[[ ]]`条件判断结构中，但是如果出现在`[ ]`结构中的话，会报错。

④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

### 5. 大括号、花括号{}

#### 5.1 常规用法

##### 5.1.1 大括号拓展

(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 `touch {a,b}.txt` 结果为`a.txt b.tx`t。第二种：对大括号中以点点`（..）`分割的顺序文件列表起拓展作用，如：`touch {a..d}.txt `结果为`a.txt b.txt c.txt d.txt`

    bogon:/home/bash # ls {ex1,ex2}.sh  
    ex1.sh  ex2.sh  
    bogon:/home/bash # ls {ex{1..3},ex4}.sh  
    ex1.sh  ex2.sh  ex3.sh  ex4.sh  
    bogon:/home/bash # ls {ex[1-3],ex4}.sh  
    ex1.sh  ex2.sh  ex3.sh  ex4.sh  

##### 5.1.2 代码块，又被称为内部组

这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。`{}`的第一个命令和左括号之间必须要有一个空格。

#### 5.2 几种特殊的替换结构

    ${var:-string},${var:+string},${var:=string},${var:?string}

##### 5.2.1 ${var:-string} 和 ${var:=string}

若变量`var`为空，则用在命令行中用`string`来替换`${var:-string}`，否则变量`var`不为空时，则用变量`var`的值来替换`${var:-string}`；对于`${var:=string}`的替换规则和`${var:-string}`是一样的，所不同之处是`${var:=string}`若`var`为空时，用`string`替换`${var:=string}`的同时，把`string`赋给变量`var`： `${var:=string}`很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。

##### 5.2.2 ${var:+string}

替换规则和上面的相反，即只有当`var`不是空的时候才替换成`string`，若`var`为空时则不替换或者说是替换成变量 `var`的值，即空值。(因为变量`var`此时为空，所以这两种说法是等价的) 

##### 5.2.3 ${var:?string}

替换规则为：若变量`var`不为空，则用变量`var`的值来替换`${var:?string}`；若变量`var`为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。

----------
> 补充扩展：在上面这五种替换结构中`string`不一定是常值的，可用另外一个变量的值或是一种命令的输出。

#### 5.3 四种模式匹配替换结

    ${var%pattern}, ${var%%pattern}, ${var#pattern}, ${var##pattern}

##### 5.3.1 第一种模式 ${variable%pattern}

这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`结尾，如果是，就从命令行把`variable`中的内容去掉右边最短的匹配模式

##### 5.3.2 第二种模式 ${variable%%pattern}

这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`结尾，如果是，就从命令行把`variable`中的内容去掉右边最长的匹配模式

##### 5.3.3 第三种模式 ${variable#pattern} 

这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`开始，如果是，就从命令行把`variable`中的内容去掉左边最短的匹配模式

##### 5.3.4 第四种模式 ${variable##pattern}

这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`结尾，如果是，就从命令行把`variable`中的内容去掉右边最长的匹配模式

----------
> 这四种模式：中都不会改变`variable`的值，其中，只有在`pattern`中使用了`*`匹配符号时，`%`和`%%`，`#`和`##`才有区别。结构中的`pattern`支持通配符，`*`表示零个或多个任意字符，`?`表示零个或一个任意字符，`[...]`表示匹配中括号里面的字符，`[!...]`表示不匹配中括号里面的字符